<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>WebGL Triangle</title>
  <style>
    canvas { width: 100%; height: 100%; }
  </style>
</head>
<body>
  <canvas id="myCanvas"></canvas>
  <script  type="module">
import { Vector, Matrix } from './linalg1.js';

const canvas = document.getElementById('myCanvas');
const gl = canvas.getContext('webgl2');
//console.log(gl);
if (!gl) {
  alert("WebGL not supported!");
}



const vertexShaderSource = `#version 300 es
  in vec4 a_position;
  void main(void) {
    gl_Position = a_position;
  }
`;

async function loadShader(url) {
  const response = await fetch(url);
  if (!response.ok) {
    console.error('Failed to load shader:', url);
    return '';
  }
  return await response.text();
}


//console.log(fragmentShaderSource);

function compileShader(gl, source, type) {
  const shader = gl.createShader(type);
  gl.shaderSource(shader, source);
  gl.compileShader(shader);
  if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
    console.error("Shader compile failed:", gl.getShaderInfoLog(shader));
  }
  return shader;
}

function createProgram(gl, vertexShaderSource, fragmentShaderSource) {
  const vertexShader = compileShader(gl, vertexShaderSource, gl.VERTEX_SHADER);
  const fragmentShader = compileShader(gl, fragmentShaderSource, gl.FRAGMENT_SHADER);
  const program = gl.createProgram();
  gl.attachShader(program, vertexShader);
  gl.attachShader(program, fragmentShader);
  gl.linkProgram(program);
  if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
    console.error("Program link failed:", gl.getProgramInfoLog(program));
  }
  return program;
}

function radians(x){return x*Math.PI/180;}

function sleep(ms) {
  return new Promise(resolve => setTimeout(resolve, ms));
}



async function main(){
  const fragmentShaderSource =await loadShader("./fragmentshader.glsl"); 

  const shaderProgram = createProgram(gl, vertexShaderSource,fragmentShaderSource );
  gl.useProgram(shaderProgram);

  //draw rect

  const vertices = new Float32Array([
    -1, 1,
    -1,-1,
    1, 1,
    1,-1
  ]);

  const buffer = gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
  gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

  const positionAttribLocation = gl.getAttribLocation(shaderProgram, "a_position");
  gl.vertexAttribPointer(positionAttribLocation, 2, gl.FLOAT, false, 0, 0);
  gl.enableVertexAttribArray(positionAttribLocation);


  const cameraPosLocation = gl.getUniformLocation(shaderProgram, 'cameraPos');
  const cameraPos = [0.0, 0.0, 0.0];
  gl.uniform3fv(cameraPosLocation, cameraPos);

  const windowsizeLocation = gl.getUniformLocation(shaderProgram, 'windowsize');
  const windowsize = [canvas.width, canvas.height];
  gl.uniform2fv(windowsizeLocation, windowsize);

  let c2w=Matrix.eye(3);
  //const rotr1=Matrix.rotationMatrix(new Vector([0,1,0]),radians(1));

  let canvasupdate=true;

  let mouse = {
    x: 0,    // Mouse X position
    y: 0,    // Mouse Y position
    left: false,  // Left button state (true = pressed, false = released)
    right: false, // Right button state (true = pressed, false = released)
    middle: false // Middle button state (true = pressed, false = released)
  };

  // Update mouse position and button state on mouse events
  canvas.addEventListener('mousemove', (event) => {
    const rect = canvas.getBoundingClientRect();
    const xcord=event.clientX - rect.left;
    const ycord=event.clientY - rect.top;
    //const dx=xcord-mouse.x;
    //const dy=event.clientY-mouse.y;

    if(mouse.left){
      
      const deltax=rect.right-rect.left;
      const deltay=rect.bottom-rect.top;
      const fovfactor=1/Math.tan(radians(120)/2);
      
      const u= c=>(2.0*c-deltax)/deltax;
      const v= c=>(2.0*c-deltay)/deltax;
      const uangle=(Math.atan(u(xcord)/fovfactor)-Math.atan(u(mouse.x)/fovfactor));
      const vangle=(Math.atan(v(ycord)/fovfactor)-Math.atan(v(mouse.y)/fovfactor));


      c2w=Matrix.rotationMatrix(new Vector([0,1,0]),uangle).mul(
          Matrix.rotationMatrix(new Vector([1,0,0]),vangle)).mul(
          c2w);
      canvasupdate=true;
    }




    mouse.x = xcord;
    mouse.y = ycord;
  });

  canvas.addEventListener('mousedown', (event) => {
    // Update mouse button states
    if (event.button === 0) mouse.left = true;    // Left button
    if (event.button === 1) mouse.middle = true;  // Middle button
    if (event.button === 2) mouse.right = true;   // Right button
  });

  canvas.addEventListener('mouseup', (event) => {
    // Update mouse button states
    if (event.button === 0) mouse.left = false;
    if (event.button === 1) mouse.middle = false;
    if (event.button === 2) mouse.right = false;
  });


  function animate(){
    //c2w=c2w.mul(rotr1).orthogonalize();//orthogonalize only against precision errors. probably unnessesary

    
    if(canvasupdate){
      const c2wLocation = gl.getUniformLocation(shaderProgram, 'c2w');
      gl.uniformMatrix3fv(c2wLocation, false, new Float32Array(c2w.array.flat()));

      gl.clearColor(0.0, 0.0, 0.0, 1.0);
      gl.clear(gl.COLOR_BUFFER_BIT);
      gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
      canvasupdate=false;
    }
    requestAnimationFrame(animate);
    
  }
  requestAnimationFrame(animate);
}
main();
  </script>
</body>
</html>